{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Relat\u00f3rio Esse relat\u00f3rio refere-se ao trabalho pr\u00e1tico da disciplina de Redes de Computadores II - CI1061 , ofertada pelo departamento de Inform\u00e1tica da Universidade Federal do Paran\u00e1 (UFPR) no ano de 2021 no per\u00edodo ERE3. O trabalho consiste na implementa\u00e7\u00e3o de um sistema cliente-servidor criptografado, por meio do algoritmo de Diffie-Hellman. A implementa\u00e7\u00e3o foi feita utilizando a linguagem Python Vers\u00e3o 3.8.10 Todos os testes foram executados no sistema operacional Linux Kernel 5.4.0-80-generic, na distribui\u00e7\u00e3o Ubuntu vers\u00e3o 20.04.2 LTS x86_64. Os logs da execu\u00e7\u00e3o de ambos os programas podem ser encontrados no diret\u00f3rio logs . C\u00f3digo Fonte O c\u00f3digo fonte pode ser encontrado clicando nos links abaixo: cliente.py servidor.py loggingutils.py encryption.py Refer\u00eancias Real Python Documenta\u00e7\u00e3o Sockets python","title":"Relat\u00f3rio"},{"location":"#relatorio","text":"Esse relat\u00f3rio refere-se ao trabalho pr\u00e1tico da disciplina de Redes de Computadores II - CI1061 , ofertada pelo departamento de Inform\u00e1tica da Universidade Federal do Paran\u00e1 (UFPR) no ano de 2021 no per\u00edodo ERE3. O trabalho consiste na implementa\u00e7\u00e3o de um sistema cliente-servidor criptografado, por meio do algoritmo de Diffie-Hellman. A implementa\u00e7\u00e3o foi feita utilizando a linguagem Python Vers\u00e3o 3.8.10 Todos os testes foram executados no sistema operacional Linux Kernel 5.4.0-80-generic, na distribui\u00e7\u00e3o Ubuntu vers\u00e3o 20.04.2 LTS x86_64. Os logs da execu\u00e7\u00e3o de ambos os programas podem ser encontrados no diret\u00f3rio logs .","title":"Relat\u00f3rio"},{"location":"API-socket/","text":"API Socket A principal biblioteca utilizada na implementa\u00e7\u00e3o \u00e9 a bilioteca socket , que fornece estruturas de dados e fun\u00e7\u00f5es para manipula\u00e7\u00e3o de sockets BSD. Ela pode ser facilmente importada utilizando: import socket A documenta\u00e7\u00e3o oficial pode ser encontrada aqui. Fun\u00e7\u00f5es utilizadas Fun\u00e7\u00e3o : socket.socket() Descri\u00e7\u00e3o : Cria um novo objeto socket BSD. S\u00e3o passados dois par\u00e2metros que indicam o protocolo utilizado para comunica\u00e7\u00e3o: socket.AF_INET : Indica a familia de endere\u00e7os (Address Family) que o protocolo ir\u00e1 utilizar, neste caso AF_INET refere-se a familia de indere\u00e7os IPv4. socket.SOCK_STREAM : Indica que a comunica\u00e7\u00e3o utilizar\u00e1 o protocolo TCP. Fun\u00e7\u00e3o : s.bind() Descri\u00e7\u00e3o : Associa um endere\u00e7o (de acordo com a familia de endere\u00e7os previamente configurada) ao socket do servidor, assim como a porta que ser\u00e1 utilizada. Neste caso foram passados o endere\u00e7o de loopback (localhost) 127.0.0.1 e a porta 1026. Fun\u00e7\u00e3o : s.connect() Descri\u00e7\u00e3o : Conecta um cliente a um servidor por meio do endere\u00e7o e porta especificados. Os valores passados s\u00e3o iguais ao de bind() . Fun\u00e7\u00e3o : s.accept() Descri\u00e7\u00e3o : Chamada bloqueante que aguarda uma conex\u00e3o com algum cliente. Ao estabelec\u00ea-la, retorna um objeto socket que representa a conex\u00e3o, assim como uma tupla com o endere\u00e7o e a porta do cliente. Fun\u00e7\u00e3o : s.send() Descri\u00e7\u00e3o : Envia uma mensagem por meio da abstra\u00e7\u00e3o de socket. Fun\u00e7\u00e3o : s.recv(n) Descri\u00e7\u00e3o : Recebe uma mensagem com no m\u00e1ximo n bytes de tamanho.","title":"API Socket"},{"location":"API-socket/#api-socket","text":"A principal biblioteca utilizada na implementa\u00e7\u00e3o \u00e9 a bilioteca socket , que fornece estruturas de dados e fun\u00e7\u00f5es para manipula\u00e7\u00e3o de sockets BSD. Ela pode ser facilmente importada utilizando: import socket A documenta\u00e7\u00e3o oficial pode ser encontrada aqui.","title":"API Socket"},{"location":"cripto/","text":"Criptografia e Diffie-Hellman A seguran\u00e7a em uma comunica\u00e7\u00e3o \u00e9 uma parte bastante importante das redes de computadores. Atualmente, muita informa\u00e7\u00e3o importante e sigilosa \u00e9 enviada e recebida a todo momento, e para que isso seja feito de maneira segura, \u00e9 necess\u00e1rio criptografar tais informa\u00e7\u00f5es. Criptografia refere-se ao ato de codificar informa\u00e7\u00f5es, transformando-as para que somente aqueles que possuem o c\u00f3digo possam entend\u00ea-la. Existem diversas t\u00e9cnicas de criptografia, no entanto, o escopo deste trabalho resume-se apenas a criptografia sim\u00e9trica. Nela, uma chave secreta \u00e9 estabelecida entre dois ou mais processos, e serve para codificar e decodificar mensagens enviadas por um meio n\u00e3o seguro. Isto \u00e9, a partir de um c\u00f3digo que somente duas ou mais partes sabem, \u00e9 poss\u00edvel comunicar-se de forma completamente sigilosa. No contexto de redes isso \u00e9 um pouco mais complicado, pois envolve um problema \u00f3bvio: Como duas partes que precisam necessariamente estabelecer comunica\u00e7\u00e3o podem estabelecer uma chave secreta sem envi\u00e1-la pelo meio? \u00c9 neste contexto que o Algoritmo de Diffie-Hellman permite estabelecer tal chave, sem que nenhum agente no meio inseguro a conhe\u00e7a. Algoritmo de Diffie-Hellman Para compreender melhor o algoritmo, exemplificaremos o seu funcionamento a partir do caso de Alice (A) e Bob (B) que desejam comunicar em segredo, no entanto, h\u00e1 um agente malicioso que est\u00e1 escutando o meio (C), e ele pretende descobrir o que est\u00e1 sendo transmitido. Isso \u00e9 ilustrado na figura a seguir. Inicialmente, \u00e9 necess\u00e1rio que Alice e Bob conhe\u00e7am dois n\u00fameros interios aleat\u00f3rios g e p . Supondo que Bob gere ambos, eles s\u00e3o transmitidos para Alice atrav\u00e9s do meio, de forma completamente p\u00fablica. O agente tem acesso a estes n\u00fameros, e ele os guarda imediatamente. Em seguida, Alice e Bob escolhem uma chave particular, que somente cada um deles sabe. Ela pode ser escolhida aleatoriamente, e \u00e9 representada por Pa para Alice e Pb para Bob. A partir disso, ambos calculam uma chave p\u00fablica : pubA = g ^ Pa mod n pubB = g ^ Pb mod n E cada um a envia pelo meio. Tamb\u00e9m interceptada pelo agente. Nesse momento, Alice e Bob podem estabelecer a chave secreta fazendo uma conta simples: Bob : chave = pubA ^ Pb mod n = ( g ^ Pa ) ^ Pb mod n Alice : chave = pubB ^ Pa mod n = ( g ^ Pb ) ^ Pa mod n Isso \u00e9 evidenciado pela propriedade da exponencia\u00e7\u00e3o de mesma base, pois: ( g ^ Pb ) ^ Pa mod n = g ^ (Pa * Pb) mod n ( g ^ Pa ) ^ Pb mod n = g ^ (Pa * Pb) mod n A partir disso esta chave pode ser usada para codificar e decodificar mensangens pelo meio. Mas e o agente que estava escutando no meio n\u00e3o seguro? Bom, ele n\u00e3o sabe como c\u00e1lcul\u00e1-la, pois a informa\u00e7\u00e3o que passou por ele foi: g e p pubA = g ^ Pa mod n pubB = g ^ Pb mod n Somente com estes 4 valores \u00e9 imposs\u00edvel calcular o valor da chave, pois n\u00e3o se sabe nem o valor de Pa nem de Pb . Isso \u00e9 poss\u00edvel atrav\u00e9s da opera\u00e7\u00e3o de resto mod , que mapeia um grande n\u00famero de entradas para um \u00fanico n\u00famero. Desta forma, s\u00f3 seria poss\u00edvel encontrar a chave \"chutando\" valores de Pa e Pb . Implementa\u00e7\u00e3o da Criptografia O algoritmo de Diffie-Hellman foi implementado no sistema cliente-servidor, que \u00e9 criptografado atrav\u00e9s do algortimo sim\u00e9trico AES da biblioteca Crypto . Inicialmente, o cliente ap\u00f3s conectar-se com sucesso ao servidor, gera os n\u00fameros aleat\u00f3rios e os envia, aguardando a chave p\u00fablica do servidor. O servidor envia sua chave p\u00fablica e recebe a chave do cliente, em seguida, ambas as partes calculam a chave secreta e a comunica\u00e7\u00e3o pode iniciar. Todas as fun\u00e7\u00f5es de codifica\u00e7\u00e3o podem ser encontradas no arquivo encryption.py que pode ser acessado aqui . Nele tr\u00eas fun\u00e7\u00f5es s\u00e3o descritas: encode_key(key) converte uma chave (inteiro) em bytes, e ajusta o seu tamanho para 16 bytes. encrypt(msg, key) codifica uma mensagem a partir da chave, tamb\u00e9m faz um padding para que ela possua um tamanho divis\u00edvel por 16, neste caso, o caractere escolhido foi '#' para o preenchimento. decrypted(msg, key) decodifica uma mensagem a partir da chave, retirando o padding feito pela codifica\u00e7\u00e3o e retornando a mensagem original.","title":"Criptografia e Diffie-Hellman"},{"location":"cripto/#criptografia-e-diffie-hellman","text":"A seguran\u00e7a em uma comunica\u00e7\u00e3o \u00e9 uma parte bastante importante das redes de computadores. Atualmente, muita informa\u00e7\u00e3o importante e sigilosa \u00e9 enviada e recebida a todo momento, e para que isso seja feito de maneira segura, \u00e9 necess\u00e1rio criptografar tais informa\u00e7\u00f5es. Criptografia refere-se ao ato de codificar informa\u00e7\u00f5es, transformando-as para que somente aqueles que possuem o c\u00f3digo possam entend\u00ea-la. Existem diversas t\u00e9cnicas de criptografia, no entanto, o escopo deste trabalho resume-se apenas a criptografia sim\u00e9trica. Nela, uma chave secreta \u00e9 estabelecida entre dois ou mais processos, e serve para codificar e decodificar mensagens enviadas por um meio n\u00e3o seguro. Isto \u00e9, a partir de um c\u00f3digo que somente duas ou mais partes sabem, \u00e9 poss\u00edvel comunicar-se de forma completamente sigilosa. No contexto de redes isso \u00e9 um pouco mais complicado, pois envolve um problema \u00f3bvio: Como duas partes que precisam necessariamente estabelecer comunica\u00e7\u00e3o podem estabelecer uma chave secreta sem envi\u00e1-la pelo meio? \u00c9 neste contexto que o Algoritmo de Diffie-Hellman permite estabelecer tal chave, sem que nenhum agente no meio inseguro a conhe\u00e7a.","title":"Criptografia e Diffie-Hellman"},{"location":"intro/","text":"Introdu\u00e7\u00e3o Neste trabalho, foi implementado um sistema cliente-servidor que comunica uma pequena passagem do conto O Depoimento de Randolph Carter de Howard Philips Lovecraft, no qual dois personagens conversam atrav\u00e9s de um r\u00e1dio. Esse sistema foi implementado de maneira criptografada, utilizando o algoritmo de Diffie-Hellman para estabelecer uma chave secreta. Modelo Cliente-Servidor O modelo cliente-servidor serve de base para a comunica\u00e7\u00e3o entre processos por meio de uma rede. Nele, existem duas importantes entidades: Servidor : Um processo que fica em modo de escuta para atender pedidos de clientes, ele est\u00e1 em constante execu\u00e7\u00e3o e aguarda uma nova comunica\u00e7\u00e3o. Cliente : Processo que inicia uma comunica\u00e7\u00e3o com algum servidor e \u00e9 atendido por ele. Isso \u00e9 ilustrado na figura abaixo. Fonte: https://en.wikipedia.org/wiki/Client%E2%80%93server_model Um servidor pode estabelecer conex\u00e3o com m\u00faltiplos processos, n\u00e3o limitando-se somente a um \u00fanico cliente. Implementa\u00e7\u00e3o A implementa\u00e7\u00e3o do sistema apresentado foi feita de forma bastante simples, no formato request/reply . Isso significa que um cliente conecta-se a um servidor, manda uma mensagem e aguarda uma resposta. A conex\u00e3o encerra-se quando n\u00e3o h\u00e1 mais mensagens a serem trocadas. Para testar o sistema, o cliente envia (sequencialmente): O que \u00e9 Warren? Warren, o que \u00e9? O que \u00e9? Warren me responda! Warren, porfavor, o que voc\u00ea encontrou? Warren, aguente firme! Estou descendo! O que.. Warren! Warren! Responda-me - Voc\u00ea est\u00e1 ai? E o servidor responde: Deus! Se voc\u00ea pudesse ver o que eu estou vendo! Carter, \u00e9 terr\u00edvel - monstruoso - inacredit\u00e1vel! N\u00e3o posso contar Carter! \u00c9 t\u00e3o absolutamente al\u00e9m do pensamento! N\u00e3o ouso lhe dizer - homem algum pode conhecer isso e continuar vivendo! Meu deus! Eu nunca sonhei com isso! Carter! Pelo amor de Deus, ponha a laje de volta e saia daqui se puder! R\u00e1pido! Largue tudo e saia! \u00c9 sua \u00fanica chance! Fa\u00e7a o que eu digo e n\u00e3o pe\u00e7a explica\u00e7\u00f5es! N\u00e3o! Voc\u00ea n\u00e3o compreende! \u00c9 tarde demais - e \u00e9 minha culpa. Devolva a laje e corra - n\u00e3o h\u00e1 nada que voc\u00ea ou qualquer outro possa fazer agora! R\u00e1pido - antes que seja tarde! IDIOTA! WARREN EST\u00c1 MORTO! Re-criando o di\u00e1logo do conto mencionado.","title":"Introdu\u00e7\u00e3o"},{"location":"intro/#introducao","text":"Neste trabalho, foi implementado um sistema cliente-servidor que comunica uma pequena passagem do conto O Depoimento de Randolph Carter de Howard Philips Lovecraft, no qual dois personagens conversam atrav\u00e9s de um r\u00e1dio. Esse sistema foi implementado de maneira criptografada, utilizando o algoritmo de Diffie-Hellman para estabelecer uma chave secreta.","title":"Introdu\u00e7\u00e3o"},{"location":"logging/","text":"Logging O logging do sistema foi feito atrav\u00e9s de fun\u00e7\u00f5es auxiliares contidas no arquivo loggingutils.py que pode ser encontrado aqui . Nele est\u00e1 descrito a classe LogFile , que possui alguns m\u00e9todos importantes: write_log : Escreve uma mensagem no log criado. log_recv : Escreve uma mensagem de recebido no log criado, seguido da mensagem recebida. log_send : Escreve a mensagem enviada no log criado. log_end : Encerra o log criado. Logs de testes Os logs de teste que utilizaram a chave correta para codificar e decodificar as mensagens s\u00e3o mostrados a seguir: client-original.log server1-original.log Neles, podemos acompanhar a narrativa dos dois personagens Carter e Warren, que tiveram um final tr\u00e1gico. No entanto, para observar o comportamento de um agente malicioso, os logs de teste com as chaves secretas incorretas tamb\u00e9m s\u00e3o mostrados a seguir : client-m.log server2-m.log Os caracteres estranhos podem ser explicados pela codifica\u00e7\u00e3o UTF-8, que interpreta bytes \"fora do lugar\" com s\u00edmbolos de certa forma aleat\u00f3ria.","title":"Logging"},{"location":"logging/#logging","text":"O logging do sistema foi feito atrav\u00e9s de fun\u00e7\u00f5es auxiliares contidas no arquivo loggingutils.py que pode ser encontrado aqui . Nele est\u00e1 descrito a classe LogFile , que possui alguns m\u00e9todos importantes: write_log : Escreve uma mensagem no log criado. log_recv : Escreve uma mensagem de recebido no log criado, seguido da mensagem recebida. log_send : Escreve a mensagem enviada no log criado. log_end : Encerra o log criado.","title":"Logging"},{"location":"server-client/","text":"Implementa\u00e7\u00e3o do sistema A partir da API de sockets e os recursos fornecidos pela linguagem Python, o sistema cliente-servidor criptografado foi implementado. A comunica\u00e7\u00e3o ocorre por meio dos padr\u00f5es TCP/IP, que \u00e9 definida na cria\u00e7\u00e3o dos sockets de cada processo. O sistema pode ser executado a partir dos comandos: python3 servidor.py python3 cliente.py O servidor inicialmente \u00e9 associado ao endere\u00e7o 127.0.0.1 (localhost) e a porta 1026 atrav\u00e9s da cria\u00e7\u00e3o de um socket e pela chamada da fun\u00e7\u00e3o bind . Em seguida, ele \u00e9 colocado em modo de escuta atrav\u00e9s de listen , que permite identific\u00e1-lo como servidor. Ap\u00f3s isso, o servidor entra em um la\u00e7o infinito que aguarda uma conex\u00e3o com algum cliente. O cliente tamb\u00e9m cria um socket para comunicar-se, no entanto, utiliza a chamada connect para conectar-se ao servidor, informando o endere\u00e7o e porta de destino. Depois que cliente e servidor estabeleceram a conex\u00e3o, o procedimento de estabelecimento da chave secreta de criptografia ocorre como descrito na se\u00e7\u00e3o anterior. Quando cada processo j\u00e1 possui a chave secreta, a comunica\u00e7\u00e3o ocorre por meio do padr\u00e3o request/reply. Neste padr\u00e3o, servidor e cliente trocam mensagens de forma sequencial, isto \u00e9, o cliente envia uma mensagem e o servidor responde, at\u00e9 que n\u00e3o existam mais mensagens a serem trocadas. A implementa\u00e7\u00e3o do servidor pode ser encontrada no arquivo servidor.py e pode ser acessado aqui . A implementa\u00e7\u00e3o do cliente pode ser encontrada no arquivo cliente.py e pode ser acessado aqui .","title":"Implementa\u00e7\u00e3o do sistema"},{"location":"server-client/#implementacao-do-sistema","text":"A partir da API de sockets e os recursos fornecidos pela linguagem Python, o sistema cliente-servidor criptografado foi implementado. A comunica\u00e7\u00e3o ocorre por meio dos padr\u00f5es TCP/IP, que \u00e9 definida na cria\u00e7\u00e3o dos sockets de cada processo. O sistema pode ser executado a partir dos comandos: python3 servidor.py python3 cliente.py O servidor inicialmente \u00e9 associado ao endere\u00e7o 127.0.0.1 (localhost) e a porta 1026 atrav\u00e9s da cria\u00e7\u00e3o de um socket e pela chamada da fun\u00e7\u00e3o bind . Em seguida, ele \u00e9 colocado em modo de escuta atrav\u00e9s de listen , que permite identific\u00e1-lo como servidor. Ap\u00f3s isso, o servidor entra em um la\u00e7o infinito que aguarda uma conex\u00e3o com algum cliente. O cliente tamb\u00e9m cria um socket para comunicar-se, no entanto, utiliza a chamada connect para conectar-se ao servidor, informando o endere\u00e7o e porta de destino. Depois que cliente e servidor estabeleceram a conex\u00e3o, o procedimento de estabelecimento da chave secreta de criptografia ocorre como descrito na se\u00e7\u00e3o anterior. Quando cada processo j\u00e1 possui a chave secreta, a comunica\u00e7\u00e3o ocorre por meio do padr\u00e3o request/reply. Neste padr\u00e3o, servidor e cliente trocam mensagens de forma sequencial, isto \u00e9, o cliente envia uma mensagem e o servidor responde, at\u00e9 que n\u00e3o existam mais mensagens a serem trocadas. A implementa\u00e7\u00e3o do servidor pode ser encontrada no arquivo servidor.py e pode ser acessado aqui . A implementa\u00e7\u00e3o do cliente pode ser encontrada no arquivo cliente.py e pode ser acessado aqui .","title":"Implementa\u00e7\u00e3o do sistema"}]}